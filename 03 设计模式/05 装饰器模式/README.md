# 装饰模式
> 动态给一个对象添加一些额外的职责，就增加功能来说，
装饰模式相比生成子类更为灵活

在装饰模式总，必然有一个最基本，最核心，最原始的接口或抽象类充当
Component抽象构建

1. **Component抽象组件:** Component是一个接口或者是抽象类，
就是定义我们最核心的对象，也就是最原始的对象，
2. **ConcreteComponent具体构件：** ConcreteComponent是最核心，最原始，最基本的接口或抽象类的实现，你要装饰的就是它。
3. **Decorator装饰角色：**一般是一个抽象类，做什么用呢？实现接口或者抽象方法，它里面可不一定有抽象的方法，在他的属性里面必然有一个private变量指向Component抽象构件
4. **具体装饰角色：**ConcreteDecoratorA和ConcreteDecoratorB是两个具体的装饰类，你要把你最核心的，最原始的，最基本的东西装饰成其他东西。

## 优点 ##
1. 装饰类和被装饰类可以独立发展，而不会相互耦合，换句话说，Component类无需知道Decorator类，Decorator可以从外部来扩展Component类的功能，而Decorator也不用知道具体的构建
2. 装饰模式是继承关系的一个替代方案，我们看装饰类Decorator，不管修饰多少层，返回的对象还是Component，实现的关系还是is-a
3. 装饰模式可以动态的扩展一个实现类的功能。

## 缺点 ##
1. 多层的装饰是比较复杂的

## 适用场景 ##
1. 需要一个类的扩展功能，给一个类增加附加功能
2. 需要动态的地给一个对象增加功能，这些功能可以动态的撤销
3. 需要为一批兄弟类进行改装或加装功能，当然是首选装饰模式

